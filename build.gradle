apply plugin: 'com.github.ben-manes.versions'

buildscript {
    dependencies {
        classpath("org.springframework.boot:spring-boot-gradle-plugin:1.3.5.RELEASE")

        // "Gradle Versions Plugin" to check for new versions of dependencies
        // https://github.com/ben-manes/gradle-versions-plugin
        // ./gradlew dependencyUpdates -Drevision=release
        classpath 'com.github.ben-manes:gradle-versions-plugin:0.12.0'
    }
    repositories {
        mavenLocal()
//        maven {
//            credentials {
//                username nexus.username
//                password nexus.password
//            }
//            url nexus.url
//        }
        jcenter()
    }
}
apply from: file("versions.gradle")

// tell spring boot to use 5.1.0 as hibernate version (default is 4.3)
ext['hibernate.version'] = versions.hibernate

description = 'Best-practice project template for quickly getting started with building modern ' +
        'and scalable server based apps and restful websites '

allprojects {
    apply plugin: 'maven'
    apply plugin: 'maven-publish'
    apply plugin: 'idea'
    version = '0.0.1-SNAPSHOT'
    group = 'com.hammocks.restutil'
    description = 'Cross platform utility for making REST calls'

//    publishing {
//        publications {
//            mavenJava(MavenPublication) {
//                from components.java
//                artifact sourcesJar
//            }
//        }
//        repositories {
//            // example on how to publish artifacts to a Dropbox hosted repo - the folder must be inside the "Public" folder.
//            // maven {
//            //     url "file:///Users/mark/Dropbox/Public/maven-repo"
//            // }
//
//            // example on how to publish artifacts to a nexus repository
//            // maven {
//            //     credentials {
//            //         username nexus.username
//            //         password nexus.password
//            //     }
//            //     url "http://${nexus.url}/content/repositories/sample-${project.version.endsWith('-SNAPSHOT') ? 'snapshot' : 'release'}-repo"
//            // }
//        }
//    }
}

subprojects {
    // aspectjVersion property is required by aspectj plugin
    project.ext {
        aspectjVersion = versions.aspectj
    }

    repositories {
        mavenLocal()
        maven {
            // dropbox repo currently contains a custom version on vertx-nubes
            url "https://dl.dropboxusercontent.com/u/3043508/maven-repo/"
        }
//        maven {
//            credentials {
//                username nexus.username
//                password nexus.password
//            }
//            url nexus.url
//        }
        jcenter()
    }

    apply plugin: 'java'
    apply plugin: 'spring-boot'

    bootRepackage {
        enabled = false
    }

    if (System.getProperty('testing', 'false') == 'false') {
        // disables automatic testing
        check.dependsOn.remove(test)
    }

    sourceCompatibility = versions.java
    targetCompatibility = versions.java

    task javadocJar(type: Jar) {
        classifier = 'javadoc'
        from javadoc.destinationDir
    }

    configurations {
        jpametamodel
        provided
        compile.extendsFrom provided
        // don't use the standard logging from spring-boot (we want log4j2)
        compile.exclude module: 'spring-boot-starter-logging'
        compile.exclude module: "spring-boot-starter-tomcat"

        testCompile.exclude module: 'spring-boot-starter-logging'
    }

    dependencies {
        provided "org.projectlombok:lombok:" + versions.lombok

//  not working with intellij idea 2016.1
//        jpametamodel("org.hibernate:hibernate-jpamodelgen:" + versions.hibernate)

//        testCompile('org.springframework.boot:spring-boot-starter-test:' + versions.springBoot) {
//            exclude(module: 'spring-boot-starter-logging')
//        }
    }

    tasks.withType(JavaCompile) {
        options.encoding = 'UTF-8'
        options.deprecation = true
    }

    configurations {
        tests
    }

    // build the archiveBaseName (for the jar) using 3 levels. TODO: find a way to support n levels
    archivesBaseName = "${project.parent.name}-${project.name}"
    archivesBaseName = "${archivesBaseName.startsWith(rootProject.name) ? archivesBaseName : rootProject.name + '-' + archivesBaseName}"

    def srcJava = 'src/main/java'
    def srcDelomboked = 'build/src-delomboked'

    task delombok() {
        description 'Delomboks the source code'
        doLast {
            ant.taskdef(classname: 'lombok.delombok.ant.Tasks$Delombok', classpath: configurations.compile.asPath, name: 'delombok')
            ant.mkdir(dir: srcDelomboked)
            ant.delombok(verbose: 'false', encoding: 'UTF-8', to: srcDelomboked, from: srcJava, classpath: configurations.compile.asPath)
        }
    }

    task sourcesJar(type: Jar, dependsOn: delombok) {
        classifier = 'sources'
        // store delomboked sources in the sources.jar so that they can be used without lombok
        // (important for gwt and j2objc)
        from file(srcDelomboked)
    }

    /**
     packages the tests of the current module so that they can be referenced by other modules of the project
     reference the test-jar like this:
     testCompile project(path: ':common:context', configuration: 'tests')
     or:
     testCompile group: 'com.kickstarter.shared', name: 'sample-shared', version: version, classifier: 'tests'
     */
    task packageTests(type: Jar) {
        classifier = 'tests'
        baseName = "${project.archivesBaseName}"
        from sourceSets.test.output
    }

    artifacts {
        archives sourcesJar
        archives javadocJar
        archives packageTests
        tests packageTests
    }

    sourceSets {

        generated {
            java { srcDirs = ['build/generated'] }
        }

        main {
            java { srcDir 'src/main/java' }
            resources { srcDir 'src/main/resources' }
        }

        test {
            java { srcDir 'src/test/java' }
            resources { srcDir 'src/test/resources' }
        }
    }

    task generateMetaModel(type: JavaCompile, group: 'build', description: 'metamodel generate') {
        source = sourceSets.main.java
        classpath = configurations.compile + configurations.jpametamodel
        options.compilerArgs = ["-proc:only"]
        destinationDir = sourceSets.generated.java.srcDirs.iterator().next()

        doFirst {
            logger.warn("Prepare dictionary structures  " + sourceSets.generated.java.srcDirs)
            //delete(sourceSets.generated.java.srcDirs)
            //sourceSets.generated.java.srcDirs.mkdirs()
        }
    }

    idea {
        module {
            name = archivesBaseName

            //if you need to put 'provided' dependencies on the classpath
//            scopes.PROVIDED.plus += [configurations.provided]

            downloadJavadoc = false
            downloadSources = true
        }
    }


    task wrapper(type: Wrapper) {
        distributionUrl = 'https://services.gradle.org/distributions/gradle-2.11-bin.zip'
    }
}

// stage task required for heroku
task stage {
    evaluationDependsOnChildren();
    dependsOn ':services:sample:server:build'
    dependsOn ':services:mediaserver:server:build'
}

def createBuildProperties(sourceSets) {
    // the environment variables BUILD_NUMBER, BUILD_ID and GIT_BRANCH are set by Jenkins
    // "tag" is set by the staging and production build
    // we store them in a build properties file which is loaded during startup
    def buildProperties = file("${sourceSets.main.output.classesDir}/build.properties")
    buildProperties << "build.tag=${System.env.tag}\n"
    buildProperties << "build.version=${version}\n"
    buildProperties << "build.number=${System.env.BUILD_NUMBER}\n"
    buildProperties << "build.timestamp=${System.env.BUILD_ID}\n"
    buildProperties << "build.scmBranch=${System.env.GIT_BRANCH}"
}

// extra configuration for "Gradle Versions Plugin": filter out release candidates etc.
dependencyUpdates.resolutionStrategy = {
    componentSelection { rules ->
        rules.all { ComponentSelection selection ->
            boolean rejected = ['alpha', 'beta', 'rc', 'cr', 'm'].any { qualifier ->
                selection.candidate.version ==~ /(?i).*[.-]${qualifier}[.\d-]*/
            }
            if (rejected) {
                selection.reject('Release candidate')
            }
        }
    }
}
